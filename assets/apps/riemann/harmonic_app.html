<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Harmonic Prime Interference</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
</head>
<body style="background-color:#111; color:#eee; font-family:monospace; padding:1em">
  <h2>Harmonic Prime Interference Visualizer</h2>
  <div class="input-row">
    <label>Number of primes: <input type="number" id="num_primes" value="100" min="1" max="10000"></label>
  </div>
  <div class="input-row">
    <label>Min t value: <input type="number" id="t_min" value="10" min="1" max="5000"></label>
    <label>t range: <input type="number" id="t_range" value="30" min="1" max="5000"></label>
  </div>
  <div class="input-row">
    <label>σ (base): <input type="number" id="sigma_base" value="0.5" step="0.01" min="0.01" max="2"></label>
    <label>σ A: <input type="number" id="sigma_a" value="0.5" step="0.01" min="0.01" max="2"></label>
    <label>σ B: <input type="number" id="sigma_b" value="0.5" step="0.01" min="0.01" max="2"></label>
  </div>
  <button onclick="runPython()">Generate Plot</button>
  <pre id="output-text"></pre>
  <div id="export-section"></div>
  <script>
    let pyodideReadyPromise = loadPyodide();

    async function runPython() {
      const pyodide = await pyodideReadyPromise;
      const numPrimes = parseInt(document.getElementById("num_primes").value);
      const tMin = parseFloat(document.getElementById("t_min").value);
      const tRange = parseFloat(document.getElementById("t_range").value);
      const tMax = tMin + tRange;
      const sigmaBase = parseFloat(document.getElementById("sigma_base").value);
      const sigmaA = parseFloat(document.getElementById("sigma_a").value);
      const sigmaB = parseFloat(document.getElementById("sigma_b").value);

      const zeros = await fetchZerosFromFile(tMin, tMax);
      await pyodide.globals.set("js_zeros", zeros);

      const outputText = document.getElementById("output-text");
      const exportSection = document.getElementById("export-section");

      outputText.textContent = "Computing, please wait...\n";
      outputText.textContent += `Fetched ${zeros.length} zeta zeros:\n` + zeros.map(z => z.toFixed(6)).join(", ") + "\n\n";

      const code = `
import matplotlib.pyplot as plt
import numpy as np
from math import log
from sympy import primerange

num_primes = ${numPrimes}
tMin = ${tMin}
tMax = ${tMax}
sigma_base = ${sigmaBase}
sigma_a = ${sigmaA}
sigma_b = ${sigmaB}

primes = list(primerange(1, 10**6))[:num_primes]
t = np.linspace(tMin, tMax, 5000)
labels = {}
sigmas = list(dict.fromkeys([
    sigma_base] + ([] if sigma_a == sigma_base else [sigma_a]) + ([] if sigma_b == sigma_base or sigma_b == sigma_a else [sigma_b])
))
colors = {
    sigma_base: "#228B22",
    sigma_a: "#DC143C",
    sigma_b: "#FF8C00"
}

fig, ax = plt.subplots()
output = ""

for sigma in sigmas:
    s = np.array([sum(p**(-sigma) * np.cos(ti*log(p)) for p in primes) for ti in t])
    label = f"\u03c3 = {sigma}"
    if sigma == sigma_base:
        label += " (base)"
    elif sigma == sigma_a:
        label += " (A)"
    elif sigma == sigma_b:
        label += " (B)"
    ax.plot(t, s, label=label, color=colors.get(sigma, None))
    output += f"{label}\n"

zeros = js_zeros
for z in zeros:
    ax.axvline(x=z, color="cyan", linestyle="--", linewidth=0.8, alpha=0.6)

ax.set_title("Harmonic Interference from Prime Log-Frequencies")
ax.set_xlabel("t")
ax.set_ylabel("Amplitude")
ax.legend()

import io
buf = io.BytesIO()
fig.savefig(buf, format='png')
buf.seek(0)
import base64
img_base64 = base64.b64encode(buf.read()).decode('utf-8')
      `;

      try {
        await pyodide.runPythonAsync(code);
        const img_base64 = pyodide.globals.get("img_base64");
        const output = pyodide.globals.get("output");

        outputText.textContent += output;
        exportSection.innerHTML = `<img src="data:image/png;base64,${img_base64}" style="max-width:100%; border:1px solid #555; margin-top:1em;">`;
      } catch (err) {
        outputText.textContent += `\nError during computation:\n${err}`;
      }
    }

    async function fetchZerosFromFile(tMin = 10, tMax = 100) {
      const response = await fetch("Zeros_zeta1_10000.txt");
      const text = await response.text();
      const lines = text.trim().split("\n");
      const zeros = lines.map(line => parseFloat(line.split(/\s+/)[1]));
      return zeros.filter(z => z >= tMin && z <= tMax && !isNaN(z));
    }
  </script>
</body>
</html>
